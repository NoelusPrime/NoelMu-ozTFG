model Car

--- Basic Class Types

-- Las unidades de distancia están en centímetros

class Config
    attributes
        PI : Real derive = (1.0).atan()*4
        RAD_TO_DEG : Real derive = 180 / PI
        DEG_TO_RAD : Real derive = PI / 180
        LINEAR_PRECISION : Real derive = 0.00000001
        ANGULAR_PRECISION : Real derive = 0.00000001
    operations
        _greaterThanOrEqualTo(num1: Real, num2: Real) : Boolean = num1 - num2 >=  0-LINEAR_PRECISION

        _lessThanOrEqualTo(num1: Real, num2: Real) : Boolean = num2 - num1 >= 0-LINEAR_PRECISION

        _AngleGreaterThanOrEqualTo(num1: Real, num2: Real) : Boolean = num1 - num2 >= 0-ANGULAR_PRECISION

        _AnglelessThanOrEqualTo(num1: Real, num2: Real) : Boolean = num2 - num1 >= 0-ANGULAR_PRECISION
end

enum Action {Forward, Rotate}
--enum State {avanzar,esquivar}

class Position
    attributes
        pos : Tuple(x : Real, y : Real, z : Real)
    operations
        --Aplica un desplazamiento a la posición actual
        move(dx: Real, dy: Real, dz: Real)
            begin
                self.pos:=Tuple{x:self.pos.x+dx, y:self.pos.y+dy,z:self.pos.z+dz};
            end
        --Teletransporta el objeto a la posición dada
        moveTo( tuple: Tuple(x:Real,y:Real,z:Real))
            begin
                self.pos := tuple;
            end
        -- Dado un punto en el espacio, un angulo y una posicion "eje" en el plano xy, devuelve la posicion resultante de rotar dicho punto sobre el punto eje los angulos indicados
        rotatePoint (tuple1 :Tuple(x : Real, y : Real, z : Real), angle1: Real, posX: Real, posY: Real) : Tuple(x : Real, y : Real, z : Real) = 
            Tuple{
                x: (tuple1.x - posX) * ((config.DEG_TO_RAD*angle1).cos()) - (tuple1.y - posY) * ((angle1*config.DEG_TO_RAD).sin()) + posX,
                y: (tuple1.x - posX) * ((config.DEG_TO_RAD*angle1).sin()) + (tuple1.y - posY) * ((angle1*config.DEG_TO_RAD).cos()) + posY,
                z: (tuple1.z)}

        -- Comprueba si la posición se encuentra fuera del environment dado por parámetro
        outOfEnvironment (env : Environment) : Boolean =    pos.x < 0 or pos.x > env.length or
                                                            pos.y < 0 or pos.y > env.width or
                                                            pos.z < 0 or pos.z > env.height
        
end

association positionConfig between
    Position [*] role position
    Config [1] role config
end


class Pose < Position
    attributes
        angle : Real
    operations
        initPose(tuple: Tuple(x:Real,y:Real,z:Real),angle1:Real, config:Config)
        begin
            self.pos := Tuple{x=tuple.x,y=tuple.y,z=tuple.z};
            self.angle := angle1;
            insert (self,config) into positionConfig;
        end
        --Rota el punto, actualizando el valor del ángulo entre 0 y 360 por si se sale del margen al sumar o restar
        rotate(angle1: Real)
        begin
            self.angle := self.angle + angle1;
            if (self.angle >= 360) then
                self.angle := self.angle - 360;
            else
                if (self.angle < 0) then
                    self.angle := self.angle + 360;
                end;
            end;
        end
end

abstract class DimensionalElement
    attributes
        length : Real
        width : Real
        height : Real
    operations
        initDimensionalElement(l: Real, w: Real, h: Real)
            begin
                self.length := l;
                self.width := w;
                self.height := h;
            end
end

class Place < DimensionalElement,Pose
    attributes

        --Los atributos b1,b2,b3 y b4 son las 4 esquinas inferiores del place
        --Los atributos h1,h2,h3 y h4 son las 4 esquinas superiores del place

        --Hay que tener cuidado con las esquinas, si no se asocia un objeto config a un place, no se podrán calcular todas las coordenadas y muchas de ellas devolveran null
        b1 : Tuple(x : Real, y : Real, z : Real) derive = self.pos
        b2 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()),z:self.pos.z}
        b3 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z}
        b4 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()) - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()) + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z}

        --h1 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x,y:self.pos.y,z:self.pos.z + self.height}
        --h2 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()),z:self.pos.z + self.height}
        --h3 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z + self.height}
        --h4 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()) - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()) + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z + self.height}

        --center : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()/2) - (self.width * (angle * config.DEG_TO_RAD).sin()/2),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()/2) + (self.width * (angle * config.DEG_TO_RAD).cos()/2),z:self.pos.z}

        --seg1 : Tuple(a1 : Real, a2 : Real, b1 : Real, b2 : Real) derive = Tuple{a1: b1.x, a2: b1.y, b1: b2.x, b2: b2.y}
        --seg2 : Tuple(a1 : Real, a2 : Real, b1 : Real, b2 : Real) derive = Tuple{a1: b1.x, a2: b1.y, b1: b3.x, b2: b3.y}
        --seg3 : Tuple(a1 : Real, a2 : Real, b1 : Real, b2 : Real) derive = Tuple{a1: b2.x, a2: b2.y, b1: b4.x, b2: b4.y}
        --seg4 : Tuple(a1 : Real, a2 : Real, b1 : Real, b2 : Real) derive = Tuple{a1: b3.x, a2: b3.y, b1: b4.x, b2: b4.y}
    operations

        init(pos: Tuple(x:Real,y:Real,z:Real),angle : Real, length: Real, width: Real, height: Real, config: Config)
            begin
                self.pos := pos;
                self.angle := angle;
                self.length := length;
                self.width := width;
                self.height := height;
                insert (self,config) into positionConfig;
            end

        --b1() : Tuple(x : Real, y : Real, z : Real) = Tuple{x:self.pos.x,y:self.pos.y,z:self.pos.z}
        --b2() : Tuple(x : Real, y : Real, z : Real) = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()),z:self.pos.z}
        --b3() : Tuple(x : Real, y : Real, z : Real) = Tuple{x:self.pos.x - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z}
        --b4() : Tuple(x : Real, y : Real, z : Real) = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()) - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()) + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z}

        h1() : Tuple(x : Real, y : Real, z : Real) = Tuple{x:self.pos.x,y:self.pos.y,z:self.pos.z + self.height}
        h2() : Tuple(x : Real, y : Real, z : Real) = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()),z:self.pos.z + self.height}
        h3() : Tuple(x : Real, y : Real, z : Real) = Tuple{x:self.pos.x - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z + self.height}
        h4() : Tuple(x : Real, y : Real, z : Real) = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()) - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()) + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z + self.height}

        center() : Tuple(x : Real, y : Real, z : Real) = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()/2) - (self.width * (angle * config.DEG_TO_RAD).sin()/2),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()/2) + (self.width * (angle * config.DEG_TO_RAD).cos()/2),z:self.pos.z}

        -- Devuelve la coordenada X menor de todas las esquinas cuando el objeto ha sido rotado "angle" grados
        _minimumX (angle1 : Real) : Real = (((((rotatePoint(Tuple{x:b1.x,y:b1.y,z:b1.z},angle1,0,0)).x).min(rotatePoint(Tuple{x:b2.x,y:b2.y,z:b2.z},angle1,0,0).x)).min(rotatePoint(Tuple{x:b3.x,y:b3.y,z:b3.z},angle1,0,0).x)).min(rotatePoint(Tuple{x:b4.x,y:b4.y,z:b4.z},angle1,0,0).x))

        -- Devuelve la coordenada X mayor de todas las esquinas cuando el objeto ha sido rotado "angle" grados
        _maximumX (angle1 : Real) : Real = (((((rotatePoint(Tuple{x:b1.x,y:b1.y,z:b1.z},angle1,0,0)).x).max(rotatePoint(Tuple{x:b2.x,y:b2.y,z:b2.z},angle1,0,0).x)).max(rotatePoint(Tuple{x:b3.x,y:b3.y,z:b3.z},angle1,0,0).x)).max(rotatePoint(Tuple{x:b4.x,y:b4.y,z:b4.z},angle1,0,0).x))

        -- Devuelve la coordenada Y menor de todas las esquinas cuando el objeto ha sido rotado "angle" grados
        _minimumY (angle1 : Real) : Real = (((((rotatePoint(Tuple{x:b1.x,y:b1.y,z:b1.z},angle1,0,0)).y).min(rotatePoint(Tuple{x:b2.x,y:b2.y,z:b2.z},angle1,0,0).y)).min(rotatePoint(Tuple{x:b3.x,y:b3.y,z:b3.z},angle1,0,0).y)).min(rotatePoint(Tuple{x:b4.x,y:b4.y,z:b4.z},angle1,0,0).y))

        -- Devuelve la coordenada Y mayor de todas las esquinas cuando el objeto ha sido rotado "angle" grados
        _maximumY (angle1 : Real) : Real = (((((rotatePoint(Tuple{x:b1.x,y:b1.y,z:b1.z},angle1,0,0)).y).max(rotatePoint(Tuple{x:b2.x,y:b2.y,z:b2.z},angle1,0,0).y)).max(rotatePoint(Tuple{x:b3.x,y:b3.y,z:b3.z},angle1,0,0).y)).max(rotatePoint(Tuple{x:b4.x,y:b4.y,z:b4.z},angle1,0,0).y))

        -- Comprueba  si en el eje X los objetos tienen puntos en común, rotados "angle" grados
        --collidingX (place1 : Place, angle : Real) : Boolean = (self.minimumX (angle) <= place1.maximumX (angle)) and (self.maximumX (angle) >= place1.minimumX (angle))
        _collidingX (place1 : Place, angle : Real) : Boolean = (config._lessThanOrEqualTo(self._minimumX(angle),place1._maximumX(angle)) and config._greaterThanOrEqualTo(self._maximumX (angle), place1._minimumX (angle)))

        -- Comprueba  si en el eje Y los objetos tienen puntos en común, rotados "angle" grados
        --collidingY (place1 : Place, angle : Real) : Boolean = (self.minimumY (angle) <= place1.maximumY (angle)) and (self.maximumY (angle) >= place1.minimumY (angle))     
        _collidingY (place1 : Place, angle : Real) : Boolean = (config._lessThanOrEqualTo(self._minimumY (angle),place1._maximumY (angle)) and config._greaterThanOrEqualTo(self._maximumY (angle),place1._minimumY (angle)))     

        -- Este método debería comprobar si rotados el place actual y el "place1" parámetro "angle1" ángulos con respecto al origen de coordenadas, existe algún eje (ya sea x o y)
        -- en el cual los 2 se superpongan
        _collidingAxis (place1: Place, angle1: Real) : Boolean =    ((_collidingX (place1,-self.angle  )) and (_collidingY (place1,-self.angle))) 
                                                                    and 
                                                                    ((_collidingX (place1,-place1.angle)) and (_collidingY (place1,-place1.angle)))
                                                                
        -- Este método comprueba si el place actual está interseccionando en algún punto con el objeto place1 que se le pasa por parámetro
        isIntersectingWith (place1: Place) : Boolean = (_collidingAxis (place1,self.angle)) and (_collidingAxis (place1,place1.angle))
        
        -- Se rota un place con respecto al punto que se especifica por parametro tantos grados como se indique
        rotatePlace(angle1: Real, posX: Real, posY: Real)
            begin
                self.pos := self.rotatePoint(self.pos,angle1,posX,posY);
                self.angle := self.angle + angle1;
                if (self.angle > 360) then
                    self.angle := self.angle - 360;
                else
                    if (self.angle < 0) then
                        self.angle := self.angle + 360;
                    end;
                end;
            end

        -- Comprueba que dicho place esté dentro de los límites del environment dado
        --isInEnvironment(e: Environment) : Boolean = e.isWithin(self.b1()) and e.isWithin(self.b2()) and e.isWithin(self.b3()) and e.isWithin(self.b4()) and
        --                                            e.isWithin(self.h1()) and e.isWithin(self.h2()) and e.isWithin(self.h3()) and e.isWithin(self.h4())

        -- Devuelve los 4 segmentos que representan las aristas en un set
        --segments() : Set(Tuple(a1 : Real, a2 : Real, b1 : Real, b2 : Real)) =  Set{seg1,seg2,seg3,seg4};
        _segments() : Set(Tuple(a1 : Real, a2 : Real, b1 : Real, b2 : Real)) =  Set{ Tuple{a1: b1.x, a2: b1.y, b1: b2.x, b2: b2.y},
                                                                                    Tuple{a1: b1.x, a2: b1.y, b1: b3.x, b2: b3.y},
                                                                                    Tuple{a1: b2.x, a2: b2.y, b1: b4.x, b2: b4.y},
                                                                                    Tuple{a1: b3.x, a2: b3.y, b1: b4.x, b2: b4.y}};

        --Comprueba si la position dada se encuentra dentro del place
        containsPosition(pos : Tuple(x:Real,y:Real,z:Real)) : Boolean = (config._greaterThanOrEqualTo(rotatePoint(pos,self.angle,0,0).x,self._minimumX(self.angle)) and config._lessThanOrEqualTo(rotatePoint(pos,self.angle,0,0).x,self._maximumX(self.angle))) and (config._greaterThanOrEqualTo(rotatePoint(pos,self.angle,0,0).y,self._minimumY(self.angle)) and config._lessThanOrEqualTo(rotatePoint(pos,self.angle,0,0).y,self._maximumY(self.angle))) and (config._lessThanOrEqualTo(pos.z,self.height) and config._greaterThanOrEqualTo(pos.z,0))
end

--- Car

class Car < ActiveObject
    attributes        
        action  : Action
        isMoving : Boolean
        isRotating : Boolean
        dodging : Boolean
        distanceLeft : Real
        distanceRight : Real
        prevAngle : Real

    operations
        init(posX : Real,posY : Real,environment: Environment,config: Config)
            begin
                declare placeCar: Place, placeTouchLeft: Place, placeTouchRight: Place, placeTouchCenter: Place, placeLight: Place, poseUltrasonic: Pose, motor: Motor, behavior: TestBehavior,
                        clock: Clock, touchLeft: TouchSensor, touchRight: TouchSensor, touchCenter: TouchSensor, light: LightSensor, ultrasonic: UltrasonicSensor;

                placeCar := new Place();
                clock := new Clock();

                --self.actualState := State.esquivar;

                self.dodging := false;
                self.distanceLeft := null;
                self.distanceRight := null;

                insert (self,config) into carConfig;

                insert (self,placeCar) into placeCar;

                self.place.init(Tuple{x=posX,y=posY,z=0},90,19,16.5,5,config);

                behavior := new TestBehavior();
                
                insert (self,behavior) into CarBehaviors;
                insert (clock,self) into Timing;

                motor := new Motor();
                insert(self, motor) into CarMotor;

                touchLeft := new TouchSensor();
                touchRight := new TouchSensor();
                touchCenter := new TouchSensor();

                light := new LightSensor();

                ultrasonic := new UltrasonicSensor();
                
                insert (self,touchLeft) into TouchSensorConnection;
                insert (self,touchRight) into TouchSensorConnection;
                insert (self,touchCenter) into TouchSensorConnection;
                
                insert (self,light) into LightSensorConnection;

                insert (self,ultrasonic) into UltrasonicSensorConnection;

                insert (environment,touchLeft) into EnvironmentCar;
                insert (environment,touchRight) into EnvironmentCar;
                insert (environment,touchCenter) into EnvironmentCar;

                insert (environment,light) into EnvironmentCar;
                insert (environment,ultrasonic) into EnvironmentCar;

                placeTouchLeft := new Place();
                placeTouchRight := new Place();
                placeTouchCenter := new Place();

                placeLight := new Place();

                poseUltrasonic := new Pose();

                insert (touchLeft,placeTouchLeft) into placeTouch;
                insert (touchRight,placeTouchRight) into placeTouch;
                insert (touchCenter,placeTouchCenter) into placeTouch;

                insert (light,placeLight) into placeLight;

                ultrasonic.pose := poseUltrasonic;

                touchLeft.place.init(Tuple{x=self.place.b3.x-6,y=self.place.b3.y+self.place.length-2,z=self.place.b3.z},45,7,3,1,config);
                touchRight.place.init(Tuple{x=self.place.b3.x+self.place.width+1,y=self.place.b3.y+self.place.length+2.95,z=self.place.b3.z},315,7,3,1,config);
                touchCenter.place.init(Tuple{x=self.place.b3.x,y=self.place.b3.y+21.8,z=self.place.b3.z},0,16.5,3,1,config);

                --touchLeft.place.init(Tuple{x=self.place.pos.x-5,y=self.place.pos.y+self.place.width,z=self.place.pos.z},45,7,3,1,config);
                --touchRight.place.init(Tuple{x=self.place.pos.x+self.place.length+0.05,y=self.place.pos.y+self.place.width+4.95,z=self.place.pos.z},315,7,3,1,config);
                --touchCenter.place.init(Tuple{x=self.place.pos.x,y=self.place.pos.y+21.8,z=self.place.pos.z},0,19,3,1,config);

                light.place.init(Tuple{x=self.place.pos.x+1,y=self.place.pos.y+1,z=self.place.pos.z},0,2,2,2,config);

                ultrasonic.pose.initPose(Tuple{x=self.place.pos.x+5,y=self.place.pos.y+5,z=self.place.pos.z},self.place.angle,config);
            end
        action()
            begin
                for b in self.behavior do
                    b.executeBehavior();
                end;
            end;

        --Comprueba si el place p está interseccionando con alguno de los sensores de choque (el sensor de luz y el de distancia no hace falta comprobarlos porque se encuentran dentro del place del coche)
        --isIntersectingWithSensors(p: Place) : Boolean = (TouchSensor.allInstances->select(t | t.place.isIntersectingWith(p)))->isEmpty = false;
        isIntersectingWithSensors(p: Place) : Boolean = (self.touch->select(t | t.place.isIntersectingWith(p)))->isEmpty = false;
        --Comprueba si el place del coche y el de sus sensores se encuentra dentro del entorno
        --isInEnvironment(e: Environment) : Boolean = self.place.isInEnvironment(e) and TouchSensor.allInstances()->select(t | self.touch->includes(t))->forAll(q | q.place.isInEnvironment(e));
        --isInEnvironment(e: Environment) : Boolean = self.place.isInEnvironment(e) and self.touch->forAll(q | q.place.isInEnvironment(e));

       
        goTo(xPos:Real,yPos:Real) 
        begin
            if (self.place.containsPosition(Tuple{x=xPos,y=yPos,z=0}) = false) then
                if (self.place.angle < self.angleTo(Tuple{x=xPos,y=yPos,z=0}) +5 and self.place.angle > self.angleTo(Tuple{x=xPos,y=yPos,z=0}) -5) then
                    self.motor.forward();
                else
                    self.orientateTo(xPos,yPos);
                end;
            end;
        end

        --Devuelve el ángulo entre el centro del coche y el objetivo
        angleTo(objectivePos : Tuple(x:Real, y:Real, z:Real)) : Real =
            if (vectorTo(Tuple{x=objectivePos.x,y=objectivePos.y,z=objectivePos.z}).x = 0) then
                if (vectorTo(Tuple{x=objectivePos.x,y=objectivePos.y,z=objectivePos.z}).y > 0) then
                    90
                else
                    270
                endif
            else
                if (vectorTo(Tuple{x=objectivePos.x,y=objectivePos.y,z=objectivePos.z}).y = 0) then
                    if (vectorTo(Tuple{x=objectivePos.x,y=objectivePos.y,z=objectivePos.z}).x > 0) then
                        0
                    else
                        180
                    endif
                else
                    if (vectorTo(Tuple{x=objectivePos.x,y=objectivePos.y,z=objectivePos.z}).x < 0) then
                        180 + (((vectorTo(Tuple{x=objectivePos.x,y=objectivePos.y,z=objectivePos.z}).y/vectorTo(Tuple{x=objectivePos.x,y=objectivePos.y,z=objectivePos.z}).x)).atan() * config.RAD_TO_DEG)
                    else
                        if (vectorTo(Tuple{x=objectivePos.x,y=objectivePos.y,z=objectivePos.z}).x > 0 and vectorTo(Tuple{x=objectivePos.x,y=objectivePos.y,z=objectivePos.z}).y < 0) then
                            360 + (((vectorTo(Tuple{x=objectivePos.x,y=objectivePos.y,z=objectivePos.z}).y/vectorTo(Tuple{x=objectivePos.x,y=objectivePos.y,z=objectivePos.z}).x)).atan() * config.RAD_TO_DEG)
                        else
                            ((vectorTo(Tuple{x=objectivePos.x,y=objectivePos.y,z=objectivePos.z}).y/vectorTo(Tuple{x=objectivePos.x,y=objectivePos.y,z=objectivePos.z}).x)).atan() * config.RAD_TO_DEG
                        endif
                    endif
                endif
            endif
         


        --Devuelve un vector normalizado que se origina en el centro del coche y acaba en el objetivo (sin contar el eje Z)
        vectorTo(objectivePos : Tuple (x:Real, y:Real, z:Real)) : Tuple (x: Real, y: Real) = Tuple{x=(objectivePos.x - self.place.center().x) /((objectivePos.x - self.place.center().x)*(objectivePos.x - self.place.center().x)+(objectivePos.y - self.place.center().y)*(objectivePos.y - self.place.center().y)).sqrt(), y=(objectivePos.y - self.place.center().y)/ ((objectivePos.x - self.place.center().x)*(objectivePos.x - self.place.center().x)+(objectivePos.y - self.place.center().y)*(objectivePos.y - self.place.center().y)).sqrt()}

        orientateTo(xPos : Real, yPos : Real)
            begin
                if (self.place.angle > self.angleTo(Tuple{x=xPos,y=yPos,z=0})) then
                    if (self.place.angle - self.angleTo(Tuple{x=xPos,y=yPos,z=0}) < 180) then
                        self.motor.rotateClockwise();
                    else
                        self.motor.rotateCounterClockwise();
                    end;
                else
                    if (self.angleTo(Tuple{x:xPos,y:yPos,z:0}) > self.place.angle) then
                        if (self.angleTo(Tuple{x:xPos,y:yPos,z:0}) - self.place.angle < 180) then
                            self.motor.rotateCounterClockwise();
                        else
                            self.motor.rotateClockwise();
                        end;
                    end;
                end;
            end;
                --if (self.angleTo(Tuple{x=xPos,y=yPos,z=0}) >= self.place.angle) then
                --    self.motor.rotateCounterClockwise();
                --else
                --    self.motor.rotateClockwise();
                --end;
    end

composition placeCar between
    Car [1] role car
    Place [1] role place
end

abstract class Behavior
    operations
        executeBehavior() begin end
    end

class TestBehavior < Behavior
    operations
        executeBehavior()
            begin
                declare objectivePos : Tuple(x:Real,y:Real,z:Real);
                objectivePos := Tuple{x=100,y=100,z=0};
                --if (self.car.place.containsPosition(objectivePos) = false) then
                    self.car.goTo(objectivePos.x,objectivePos.y);
                --end;
            end
end

composition CarBehaviors between
    Car [1] role car
    Behavior [1..*] role behavior ordered
end 

abstract class Sensor
end

class TouchSensor < Sensor
    attributes
        isPressed : Boolean --Actualmente no se usa
end

composition placeTouch between
    TouchSensor [1] role touch
    Place [1] role place
end

association sensorConfig between
    Sensor [*] role sensor
    Config [1] role config
end


class LightSensor < Sensor
    attributes
        --lightValue : Integer    derive = self.colorBelow()
    operations
        --Devuelve true si debajo del sensor hay un objeto linea
        --isLineBelow() : Boolean = Line.allInstances().place->select(p | p.isIntersectingWith(self.place))->isEmpty = false
        isLineBelow() : Boolean = self.env.element.place->select(p | p.isIntersectingWith(self.place) and p.element.oclIsTypeOf(Line))->isEmpty = false

        --Devuelve el valor que tiene la linea que se encuentra debajo del sensor
        colorBelow() : Integer =
                if (isLineBelow() = false) then
                    0
                else
                    Line.allInstances()->any(l | l.place->select( p | p.isIntersectingWith(self.place))->isEmpty = false).color
                    --self.env.element->any(l | l.place->select( p | p.isIntersectingWith(self.place) and l.oclIsTypeOf(Line))->isEmpty = false).color
                endif
end

composition placeLight between
    LightSensor [1] role light
    Place [1] role place
end

class UltrasonicSensor < Sensor
    attributes
        pose : Pose
        --direction : Tuple(v1: Real, v2: Real) derive = Tuple{v1=(pose.angle*self.car.config.DEG_TO_RAD).cos(),v2=(pose.angle*self.car.config.DEG_TO_RAD).sin()}
    operations
        distanceForward() : Real = (self.env.element->select(e | e.oclIsTypeOf(Box)).place._segments()->collect(s | self._resolveRayIntersection(s)))->select(tuple | tuple.t1 >= 0 and tuple.t2 >= 0 and tuple.t2 <= 1).t1->min()
        --(self.env.element->select(e | e.oclIsTypeOf(Box)).place._segments()->collect(s | self._resolveRayIntersection(s)))->select(tuple | tuple.t1 >= 0 and tuple.t2 >= 0 and tuple.t2 <= 1).t1->min()
        --(Box.allInstances().place._segments()->collect(s | self._resolveRayIntersection(s)))->select(tuple | tuple.t1 >= 0 and tuple.t2 >= 0 and tuple.t2 <= 1).t1->min()

        _resolveRayIntersection (seg : Tuple(a1: Real, a2: Real, b1: Real, b2: Real)) : Tuple(t1: Real, t2: Real) = Tuple{ 
            t1=((-self.pose.pos.x*seg.b2+seg.a1*seg.b2+self.pose.pos.x*seg.a2+seg.b1*self.pose.pos.y-seg.a2*seg.b1-seg.a1*self.pose.pos.y)/(self._direction().v1*seg.b2-self._direction().v1*seg.a2-seg.b1*self._direction().v2+seg.a1*self._direction().v2))
            ,
            t2=((-seg.a1*self._direction().v2+self.pose.pos.x*self._direction().v2+seg.a2*self._direction().v1-self.pose.pos.y*self._direction().v1)/(seg.b1*self._direction().v2-seg.a1*self._direction().v2-seg.b2*self._direction().v1+seg.a2*self._direction().v1))}

        _direction() : Tuple(v1: Real, v2: Real) = Tuple{v1=(pose.angle*self.car.config.DEG_TO_RAD).cos(),v2=(pose.angle*self.car.config.DEG_TO_RAD).sin()}     

end

composition UltrasonicSensorConnection between
    Car [1] role car
    UltrasonicSensor [0..1] role ultrasonic
end

composition LightSensorConnection between
    Car [1] role car
    LightSensor [0..1] role light
end

composition TouchSensorConnection between
    Car [1] role car
    TouchSensor [0..3] role touch
end

class Motor
    attributes
        linearSpeed : Real init: 5
        angularSpeed : Real init: 5
    operations

        _isIntersecting() : Boolean =     
                                        (self.car.light.env.element.place->select(p | self.car.isIntersectingWithSensors(p))->isEmpty() = false)
                                        or
                                        (self.car.light.env.element.place->select(p | self.car.place.isIntersectingWith(p))->isEmpty() = false)
        
                                        --(Box.allInstances->select(p | p.place->select(r | self.car.place.isIntersectingWith(r))->isEmpty() = false)->isEmpty() = false)
                                        --or
                                        --(Box.allInstances->select(q | q.place->select(t | self.car.isIntersectingWithSensors(t))->isEmpty() = false)->isEmpty() = false);

        forward()
            begin
                declare previousPos : Tuple(x:Real,y:Real,z:Real);
                previousPos := self.car.place.pos;
                
                self.car.place.move(
                                        self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0);
                for TouchSensor in self.car.touch do
                TouchSensor.place.move(
                                          self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                          self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                          0);
                end;
                self.car.light.place.move(
                                        self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0
                );
                self.car.ultrasonic.pose.move(
                                        self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0
                );

                --if  (self._isIntersecting())
                if ((self.car.light.env.element.place->select(p | self.car.isIntersectingWithSensors(p))->isEmpty() = false))

                
                then

                    for touch in self.car.touch->select(s | s.env.element.place->select(e | s.place.isIntersectingWith(e) and e.element.oclIsTypeOf(Box))->isEmpty = false) do
                        touch.isPressed := true;
                    end;

                    self.car.place.pos := previousPos;
                   for TouchSensor in self.car.touch do
                    TouchSensor.place.move(
                                        -self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        -self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0);
                    end;
                    self.car.light.place.move(
                                        -self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        -self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0
                    );
                    self.car.ultrasonic.pose.move(
                                        -self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        -self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0
                    );
                end;
            end;

        backward()
            begin
                declare previousPos : Tuple(x:Real,y:Real,z:Real);
                previousPos := self.car.place.pos;
                self.car.place.move(
                                        -self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        -self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0);
                for TouchSensor in self.car.touch do
                TouchSensor.place.move(
                                        -self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        -self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0);
                end;
                self.car.light.place.move(
                                        -self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        -self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0);
                self.car.ultrasonic.pose.move(
                                        -self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        -self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0);

                if  (self._isIntersecting())
                    
                then
                    
                    for touch in self.car.touch->select(s | s.env.element.place->select(e | s.place.isIntersectingWith(e) and e.element.oclIsTypeOf(Box))->isEmpty = false) do
                        touch.isPressed := true;
                    end;

                    self.car.place.pos := previousPos;
                    for TouchSensor in self.car.touch do
                    TouchSensor.place.move(
                                        self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0);
                    end;
                    self.car.light.place.move(
                                        self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0
                    );
                    self.car.ultrasonic.pose.move(
                                        self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        self.linearSpeed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0
                    );
                end;
            end;

      
        rotateClockwise()
            begin
                for TouchSensor in self.car.touch do
                    TouchSensor.place.rotatePlace(self.angularSpeed*self.car.clock.tickResolution * (-1),self.car.place.center().x,self.car.place.center().y);
                end;
                self.car.light.place.rotatePlace(self.angularSpeed*self.car.clock.tickResolution * (-1),self.car.place.center().x,self.car.place.center().y);
                self.car.ultrasonic.pose.moveTo(self.car.ultrasonic.pose.rotatePoint(self.car.ultrasonic.pose.pos,self.angularSpeed*self.car.clock.tickResolution * (-1),self.car.place.center().x,self.car.place.center().y));
                self.car.ultrasonic.pose.rotate(self.angularSpeed*self.car.clock.tickResolution * (-1));
                self.car.place.rotatePlace(self.angularSpeed*self.car.clock.tickResolution * (-1), self.car.place.center().x,self.car.place.center().y);

                if  (self._isIntersecting())
                     
                then

                    for touch in self.car.touch->select(s | s.env.element.place->select(e | s.place.isIntersectingWith(e) and e.element.oclIsTypeOf(Box))->isEmpty = false) do
                        touch.isPressed := true;
                    end;

                    for TouchSensor in self.car.touch do
                        TouchSensor.place.rotatePlace(self.angularSpeed*self.car.clock.tickResolution,self.car.place.center().x,self.car.place.center().y);
                    end;
                    self.car.light.place.rotatePlace(self.angularSpeed*self.car.clock.tickResolution,self.car.place.center().x,self.car.place.center().y);
                    self.car.ultrasonic.pose.moveTo(self.car.ultrasonic.pose.rotatePoint(self.car.ultrasonic.pose.pos,self.angularSpeed*self.car.clock.tickResolution,self.car.place.center().x,self.car.place.center().y));
                    self.car.ultrasonic.pose.rotate(self.angularSpeed*self.car.clock.tickResolution);
                    self.car.place.rotatePlace(self.angularSpeed*self.car.clock.tickResolution, self.car.place.center().x,self.car.place.center().y);
                end;
            end;

        rotateCounterClockwise()
            begin
                for TouchSensor in self.car.touch do
                    TouchSensor.place.rotatePlace(self.angularSpeed*self.car.clock.tickResolution,self.car.place.center().x,self.car.place.center().y);
                end;
                self.car.light.place.rotatePlace(self.angularSpeed*self.car.clock.tickResolution,self.car.place.center().x,self.car.place.center().y);
                self.car.ultrasonic.pose.moveTo(self.car.ultrasonic.pose.rotatePoint(self.car.ultrasonic.pose.pos,self.angularSpeed*self.car.clock.tickResolution,self.car.place.center().x,self.car.place.center().y));
                self.car.ultrasonic.pose.rotate(self.angularSpeed*self.car.clock.tickResolution);
                self.car.place.rotatePlace(self.angularSpeed*self.car.clock.tickResolution, self.car.place.center().x,self.car.place.center().y);

                if  (self._isIntersecting())
                
                then

                    for touch in self.car.touch->select(s | s.env.element.place->select(e | s.place.isIntersectingWith(e) and e.element.oclIsTypeOf(Box))->isEmpty = false) do
                        touch.isPressed := true;
                    end;

                    for TouchSensor in self.car.touch do
                        TouchSensor.place.rotatePlace(self.angularSpeed*self.car.clock.tickResolution * (-1),self.car.place.center().x,self.car.place.center().y);
                    end;
                    self.car.light.place.rotatePlace(self.angularSpeed*self.car.clock.tickResolution * (-1),self.car.place.center().x,self.car.place.center().y);
                    self.car.ultrasonic.pose.moveTo(self.car.ultrasonic.pose.rotatePoint(self.car.ultrasonic.pose.pos,self.angularSpeed*self.car.clock.tickResolution * (-1),self.car.place.center().x,self.car.place.center().y));
                    self.car.ultrasonic.pose.rotate(self.angularSpeed*self.car.clock.tickResolution * (-1));
                    self.car.place.rotatePlace(self.angularSpeed*self.car.clock.tickResolution * (-1), self.car.place.center().x,self.car.place.center().y);
                --
                end;
            end;
end

association carConfig between
    Car [*] role car
    Config [1] role config
end

composition CarMotor between
    Car [1] role car
    Motor [1] role motor
end

------- ENVIRONMENT

class Environment < DimensionalElement
    operations
    init(l: Real, w: Real, h: Real, config: Config) 
        begin
            declare b1: Box, b2: Box, b3: Box, b4: Box, p1: Place, p2: Place, p3: Place, p4: Place ;

            self.length := l;
            self.width := w;
            self.height := h;

            b1 := new Box();
            b2 := new Box();
            b3 := new Box();
            b4 := new Box();

            p1 := new Place();
            p2 := new Place();
            p3 := new Place();
            p4 := new Place();

            p1.init(Tuple{x=0,y=0,z=0},0,l,0,0,config);
            p2.init(Tuple{x=0,y=0,z=0},0,0,w,0,config);
            p3.init(Tuple{x=0,y=w,z=0},0,l,0,0,config);
            p4.init(Tuple{x=l,y=0,z=0},0,0,w,0,config);

            insert (b1,p1) into ElementPlaces;
            insert (b2,p2) into ElementPlaces;
            insert (b3,p3) into ElementPlaces;
            insert (b4,p4) into ElementPlaces;

            insert (self,b1) into ElementOnTheFloor;
            insert (self,b2) into ElementOnTheFloor;
            insert (self,b3) into ElementOnTheFloor;
            insert (self,b4) into ElementOnTheFloor;

        end
    isWithin (tuple1 : Tuple(x:Real,y:Real,z:Real)) : Boolean =     tuple1.x >= 0 and tuple1.x <= self.length
                                                                and tuple1.y >= 0 and tuple1.y <= self.width
                                                                and tuple1.z >= 0 and tuple1.z <= self.height
end

abstract class EnvironmentElement
end

class Line < EnvironmentElement
    attributes
        color: Integer
    constraints
        inv colorBetween: self.color >= 0 and self.color <= 255
    end

class Box < EnvironmentElement
    attributes
    operations
        init(pos: Tuple(x:Real,y:Real,z:Real),angle : Real, length: Real, width: Real, height: Real, config: Config)
            begin
                declare placeBox : Place;
                placeBox := new Place();
                placeBox.init(pos,angle,length,width,height,config);
                insert (self,placeBox) into ElementPlaces;
            end;
    end

association EnvironmentCar between
    Environment [1] role env
    Sensor [*] role sensor
    end

composition ElementOnTheFloor between  
    Environment [1] role env
    EnvironmentElement [*] role element
    end

composition ElementPlaces between
    EnvironmentElement [1] role element
    Place [1..*] role place
    end

------- SIMULATION 

abstract class ActiveObject
    operations
        action() begin end
    end

class Clock
    attributes
        now : Integer                 init : 0
        tickResolution : Integer      init : 1
    operations
        tick()
            begin
                    declare snapshot : Snapshot, car : Car;
                    for object in self.activeObject do
                        object.action();
                    end;
                    self.now := self.now + self.tickResolution;
                    --snapshot := new Snapshot();
                    --car := self.activeObject->first.oclAsType(Car);
                    --snapshot.init(car,car.light.env,self.now);
            end
    end

association Timing between
    Clock [1] role clock
    ActiveObject [*] role activeObject ordered
end

-- Snapshots

class Snapshot
    attributes
        car : Car
        environment : Environment
        time : Integer
    operations
        init(car : Car, environment : Environment, time : Integer)
            begin
                self.car := car;
                self.environment := environment;
                self.time := time;
            end
end

-- Tests

class Tester
    operations
        testForward()
            begin
            ----------------------------------------------------------------
                declare environment: Environment, car: Car, config: Config;

                config := new Config();
                environment := new Environment();
                car := new Car();

                config := new Config();
                environment.init(1000,1000,100,config);
                car.init(50,50,environment,config);
            ----------------------------------------------------------------
                car.motor.forward();
            end
            post testForwardCorrect: true;
        
        testBackward()
            begin
            ----------------------------------------------------------------
                declare environment: Environment, car: Car, config: Config;

                config := new Config();
                environment := new Environment();
                car := new Car();

                config := new Config();
                environment.init(1000,1000,100,config);
                car.init(50,50,environment,config);
            ----------------------------------------------------------------
            end
            post testBackward: true;
        
        testRotateClockwise()
            begin
            ----------------------------------------------------------------
                declare environment: Environment, car: Car, config: Config;

                config := new Config();
                environment := new Environment();
                car := new Car();

                config := new Config();
                environment.init(1000,1000,100,config);
                car.init(50,50,environment,config);
            ----------------------------------------------------------------
            end
            post testRotateClockwise: true;
        
        testRotateCounterClockwise()
            begin
            ----------------------------------------------------------------
                declare environment: Environment, car: Car, config: Config;

                config := new Config();
                environment := new Environment();
                car := new Car();

                config := new Config();
                environment.init(1000,1000,100,config);
                car.init(50,50,environment,config);
            ----------------------------------------------------------------
            end
            post testRotateCounterClockwise: true;

        testGoTo()
            begin
            ----------------------------------------------------------------
                declare environment: Environment, car: Car, config: Config;

                config := new Config();
                environment := new Environment();
                car := new Car();

                config := new Config();
                environment.init(1000,1000,100,config);
                car.init(50,50,environment,config);
            ----------------------------------------------------------------
            end
            post testGoTo: true;

        testUltrasonicSensor()
            begin
            ----------------------------------------------------------------
                declare environment: Environment, car: Car, config: Config;

                config := new Config();
                environment := new Environment();
                car := new Car();

                config := new Config();
                environment.init(1000,1000,100,config);
                car.init(50,50,environment,config);
            ----------------------------------------------------------------
            end
            post testUltrasonicSensor : true;

        testTouchSensor()
            begin
            ----------------------------------------------------------------
                declare environment: Environment, car: Car, config: Config;

                config := new Config();
                environment := new Environment();
                car := new Car();

                config := new Config();
                environment.init(1000,1000,100,config);
                car.init(50,50,environment,config);
            ----------------------------------------------------------------
            end
            post testTouchSensor: true;

        testLightSensor()
            begin
            ----------------------------------------------------------------
                declare environment: Environment, car: Car, config: Config;

                config := new Config();
                environment := new Environment();
                car := new Car();

                config := new Config();
                environment.init(1000,1000,100,config);
                car.init(50,50,environment,config);
            ----------------------------------------------------------------
            end
            post testLightSensor: true;
end



