model Car

--- Basic Class Types

-- Las unidades de distancia están en centímetros

class Config
    attributes
        PI : Real derive = (1.0).atan()*4
        RAD_TO_DEG : Real derive = 180 / PI
        DEG_TO_RAD : Real derive = PI / 180
        LINEAR_PRECISSION : Real derive = 0.00000001
        ANGULAR_PRECISSION : Real derive = 0.00000001
end

enum Action {Forward, Rotate}
enum Color {Black,Yellow, Red, Blue}

class Position
    attributes
        pos : Tuple(x : Real, y : Real, z : Real)
    operations
        move( dx: Real, dy: Real, dz: Real)
            begin
                self.pos:=Tuple{x:self.pos.x+dx, y:self.pos.y+dy,z:self.pos.z+dz};
            end

            -- Dado un punto en el espacio, un angulo y una posicion "eje" en el plano xy, devuelve la posicion resultante de rotar dicho punto sobre el punto eje los angulos indicados
        rotatePoint (tuple1 :Tuple(x : Real, y : Real, z : Real), angle1: Real, posX: Real, posY: Real) : Tuple(x : Real, y : Real, z : Real) = 
            Tuple{
                x: (tuple1.x - posX) * ((config.DEG_TO_RAD*angle1).cos()) - (tuple1.y - posY) * ((angle1*config.DEG_TO_RAD).sin()) + posX,
                y: (tuple1.x - posX) * ((config.DEG_TO_RAD*angle1).sin()) + (tuple1.y - posY) * ((angle1*config.DEG_TO_RAD).cos()) + posY,
                z: (tuple1.z)}
        outOfEnvironment (env : Environment) : Boolean = pos.x < 0 or pos.x > env.size.length or
                                                        pos.y < 0 or pos.y > env.size.width or
                                                        pos.z < 0 or pos.z > env.size.height
end

association positionConfig between
    Position [*] role position
    Config [1] role config
end


class Pose < Position
    attributes
        angle : Real
    operations
        rotate(angle : Real)
        begin
            self.angle := angle;
        end
end

class Size
    attributes
        length : Real
        width : Real
        height : Real
end

class Place < Size,Pose
    attributes

        --Los atributos b1,b2,b3 y b4 son las 4 esquinas inferiores del place
        --Los atributos h1,h2,h3 y h4 son las 4 esquinas superiores del place

        --Hay que tener cuidado con las esquinas, si no se asocia un objeto config a un place, no se podrán calcular todas las coordenadas y muchas de ellas devolveran null
        b1 : Tuple(x : Real, y : Real, z : Real) derive = self.pos
        b2 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()),z:self.pos.z}
        b3 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z}
        b4 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()) - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()) + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z}

        h1 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x,y:self.pos.y,z:self.pos.z + self.height}
        h2 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()),z:self.pos.z + self.height}
        h3 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z + self.height}
        h4 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()) - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()) + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z + self.height}

        center : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()/2) - (self.width * (angle * config.DEG_TO_RAD).sin()/2),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()/2) + (self.width * (angle * config.DEG_TO_RAD).cos()/2),z:self.pos.z}
    operations

        init(pos: Tuple(x:Real,y:Real,z:Real),angle : Real, length: Real, width: Real, height: Real)
            begin
                self.pos := pos;
                self.angle := angle;
                self.length := length;
                self.width := width;
                self.height := height;
            end

        -- Devuelve la coordenada X menor de todas las esquinas cuando el objeto ha sido rotado "angle" grados
        minimumX (angle1 : Real) : Real = (((((rotatePoint(Tuple{x:b1.x,y:b1.y,z:b1.z},angle1,0,0)).x).min(rotatePoint(Tuple{x:b2.x,y:b2.y,z:b2.z},angle1,0,0).x)).min(rotatePoint(Tuple{x:b3.x,y:b3.y,z:b3.z},angle1,0,0).x)).min(rotatePoint(Tuple{x:b4.x,y:b4.y,z:b4.z},angle1,0,0).x))

        -- Devuelve la coordenada X mayor de todas las esquinas cuando el objeto ha sido rotado "angle" grados
        maximumX (angle1 : Real) : Real = (((((rotatePoint(Tuple{x:b1.x,y:b1.y,z:b1.z},angle1,0,0)).x).max(rotatePoint(Tuple{x:b2.x,y:b2.y,z:b2.z},angle1,0,0).x)).max(rotatePoint(Tuple{x:b3.x,y:b3.y,z:b3.z},angle1,0,0).x)).max(rotatePoint(Tuple{x:b4.x,y:b4.y,z:b4.z},angle1,0,0).x))

        -- Devuelve la coordenada Y menor de todas las esquinas cuando el objeto ha sido rotado "angle" grados
        minimumY (angle1 : Real) : Real = (((((rotatePoint(Tuple{x:b1.x,y:b1.y,z:b1.z},angle1,0,0)).y).min(rotatePoint(Tuple{x:b2.x,y:b2.y,z:b2.z},angle1,0,0).y)).min(rotatePoint(Tuple{x:b3.x,y:b3.y,z:b3.z},angle1,0,0).y)).min(rotatePoint(Tuple{x:b4.x,y:b4.y,z:b4.z},angle1,0,0).y))

        -- Devuelve la coordenada Y mayor de todas las esquinas cuando el objeto ha sido rotado "angle" grados
        maximumY (angle1 : Real) : Real = (((((rotatePoint(Tuple{x:b1.x,y:b1.y,z:b1.z},angle1,0,0)).y).max(rotatePoint(Tuple{x:b2.x,y:b2.y,z:b2.z},angle1,0,0).y)).max(rotatePoint(Tuple{x:b3.x,y:b3.y,z:b3.z},angle1,0,0).y)).max(rotatePoint(Tuple{x:b4.x,y:b4.y,z:b4.z},angle1,0,0).y))

        -- Comprueba  si en el eje X los objetos tienen puntos en común, rotados "angle" grados
        collidingX (place1 : Place, angle : Real) : Boolean = (self.minimumX (angle) <= place1.maximumX (angle)) and (self.maximumX (angle) >= place1.minimumX (angle))

        -- Comprueba  si en el eje Y los objetos tienen puntos en común, rotados "angle" grados
        collidingY (place1 : Place, angle : Real) : Boolean = (self.minimumY (angle) <= place1.maximumY (angle)) and (self.maximumY (angle) >= place1.minimumY (angle))     


        -- Este método debería comprobar si rotados el place actual y el "place1" parámetro "angle1" ángulos con respecto al origen de coordenadas, existe algún eje (ya sea x o y)
        -- en el cual los 2 se superpongan
        collidingAxis (place1: Place, angle1: Real) : Boolean = ((collidingX (place1,-self.angle  )) and (collidingY (place1,-self.angle))) 
                                                                and 
                                                                ((collidingX (place1,-place1.angle)) and (collidingY (place1,-place1.angle)))
                                                                


        -- Este método comprueba si el place actual está interseccionando en algún punto con el objeto place1 que se le pasa por parámetro
        isIntersectingWith (place1: Place) : Boolean = (collidingAxis (place1,self.angle)) and (collidingAxis (place1,place1.angle))
        
        
        -- Se rota un place con respecto al punto que se especifica por parametro tantos grados como se indique
        rotatePlace(angle1: Real, posX: Real, posY: Real)
            begin
                self.pos := self.rotatePoint(self.pos,angle1,posX,posY);
                self.angle := self.angle + angle1;
            end
end

--- Car

class Car < ActiveObject
    attributes
        place : Place
        action : Action
        isMoving : Boolean
        isRotating : Boolean
    operations
        init(config: Config)
            begin
                declare placeCar: Place, placeTouchLeft: Place, placeTouchRight: Place, placeTouchCenter: Place, motor: Motor, behavior: TestBehavior,
                        clock: Clock, touchLeft: TouchSensor, touchRight: TouchSensor, touchCenter: TouchSensor;

                placeCar := new Place();
                clock := new Clock();

                self.place := placeCar;
                placeCar.length := 19;
                placeCar.width := 16.5;
                placeCar.height := 5;
                placeCar.pos := Tuple{x=10,y=10,z=0};
                placeCar.angle := 0;

                insert (self.place,config) into positionConfig;

                behavior := new TestBehavior();
                
                insert (self,behavior) into CarBehaviors;
                insert (clock,self) into Timing;

                motor := new Motor();
                insert(self, motor) into CarMotor;

                touchLeft := new TouchSensor();
                touchRight := new TouchSensor();
                touchCenter := new TouchSensor();

                insert (self,touchLeft) into TouchSensorConnection;
                insert (self,touchRight) into TouchSensorConnection;
                insert (self,touchCenter) into TouchSensorConnection;
                

                placeTouchLeft := new Place();
                placeTouchRight := new Place();
                placeTouchCenter := new Place();

                insert (placeTouchLeft,config) into positionConfig;
                insert (placeTouchRight,config) into positionConfig;
                insert (placeTouchCenter,config) into positionConfig;

                touchLeft.place := placeTouchLeft;
                touchRight.place := placeTouchRight;
                touchCenter.place := placeTouchCenter;

                touchLeft.place.init(Tuple{x=self.place.pos.x-5,y=self.place.pos.y+self.place.width,z=self.place.pos.z},45,7,3,1);
                touchRight.place.init(Tuple{x=self.place.pos.x+self.place.length+0.05,y=self.place.pos.y+self.place.width+4.95,z=self.place.pos.z},315,7,3,1);
                touchCenter.place.init(Tuple{x=self.place.pos.x,y=self.place.pos.y+21.8,z=self.place.pos.z},0,19,3,1);
            end
        action()
            begin
                for b in self.behavior do
                    b.executeBehavior();
                end;
            end;
        --Comprueba si el place p está interseccionando con alguno de los sensores de choque
        isIntersectingWithSensors(p: Place) : Boolean = (TouchSensor.allInstances->select(t | t.place.isIntersectingWith(p)))->isEmpty = false;
    end

abstract class Behavior
    operations
        executeBehavior() begin end
    end

class TestBehavior < Behavior
    operations
        executeBehavior()
            begin
                self.car.motor.forward();
            end
end

composition CarBehaviors between
    Car [1] role car
    Behavior [1..*] role behavior ordered
end 

abstract class Sensor
end

class TouchSensor < Sensor
    attributes
        place : Place
        isPressed : Boolean     derived: false
end

association sensorConfig between
    Sensor [*] role sensor
    Config [1] role config
end


class LightSensor < Sensor
    attributes
        position : Position
        lightValue : Integer    derived:45
end

class UltrasonicSensor < Sensor
    attributes
        pose : Pose
        distance : Integer   derived: 40 -- cm
end

composition UltrasonicSensorConnection between
    Car [1] role car
    UltrasonicSensor [0..1] role sound
end

composition LightSensorConnection between
    Car [1] role car
    LightSensor [0..1] role light
end

composition TouchSensorConnection between
    Car [1] role car
    TouchSensor [0..3] role touch
end

class Motor
    attributes
        speed : Real init: 10
    operations

        forward()
            begin
                declare previousPos : Tuple(x:Real,y:Real,z:Real);
                previousPos := self.car.place.pos;
                self.car.place.move(
                                                    self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                                    self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                                    0);
                for TouchSensor in self.car.touch do
                TouchSensor.place.move(
                                        self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0);
                end;
                if  ((ElementPart.allInstances->select(p | self.car.place.isIntersectingWith(p.place))->isEmpty() = false) 
                    or 
                    (ElementPart.allInstances->select(q | self.car.isIntersectingWithSensors(q.place)))->isEmpty= false) then
                    
                    self.car.place.pos := previousPos;
                    for TouchSensor in self.car.touch do
                    TouchSensor.place.move(
                                        -self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        -self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0);
                    end;
                end;
            end;

        backward()
            begin
                declare previousPos : Tuple(x:Real,y:Real,z:Real);
                previousPos := self.car.place.pos;
                self.car.place.move(
                                                    -self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                                    -self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                                    0);
                for TouchSensor in self.car.touch do
                TouchSensor.place.move(
                                        -self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        -self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0);
                end;
                if  ((ElementPart.allInstances->select(p | self.car.place.isIntersectingWith(p.place))->isEmpty() = false) 
                    or 
                    (ElementPart.allInstances->select(q | self.car.isIntersectingWithSensors(q.place)))->isEmpty= false) then
                    
                    self.car.place.pos := previousPos;
                    for TouchSensor in self.car.touch do
                    TouchSensor.place.move(
                                        self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).cos(),
                                        self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.car.config.DEG_TO_RAD).sin(),
                                        0);
                    end;
                end;
            end;

        
        rotateClockwise()
            begin
                for TouchSensor in self.car.touch do
                    TouchSensor.place.rotatePlace(self.speed*self.car.clock.tickResolution * (-1),self.car.place.center.x,self.car.place.center.y);
                end;
                self.car.place.rotatePlace(self.speed*self.car.clock.tickResolution * (-1), self.car.place.center.x,self.car.place.center.y);
                --
                if  ((ElementPart.allInstances->select(p | self.car.place.isIntersectingWith(p.place))->isEmpty() = false) 
                    or 
                    (ElementPart.allInstances->select(q | self.car.isIntersectingWithSensors(q.place)))->isEmpty= false) then

                    for TouchSensor in self.car.touch do
                        TouchSensor.place.rotatePlace(self.speed*self.car.clock.tickResolution,self.car.place.center.x,self.car.place.center.y);
                    end;
                    self.car.place.rotatePlace(self.speed*self.car.clock.tickResolution, self.car.place.center.x,self.car.place.center.y);
                --
                end;
            end;
        rotateAntiClockwise()
            begin
                for TouchSensor in self.car.touch do
                    TouchSensor.place.rotatePlace(self.speed*self.car.clock.tickResolution,self.car.place.center.x,self.car.place.center.y);
                end;
                self.car.place.rotatePlace(self.speed*self.car.clock.tickResolution, self.car.place.center.x,self.car.place.center.y);
                --
                if  ((ElementPart.allInstances->select(p | self.car.place.isIntersectingWith(p.place))->isEmpty() = false) 
                    or 
                    (ElementPart.allInstances->select(q | self.car.isIntersectingWithSensors(q.place)))->isEmpty= false) then

                    for TouchSensor in self.car.touch do
                        TouchSensor.place.rotatePlace(self.speed*self.car.clock.tickResolution * (-1),self.car.place.center.x,self.car.place.center.y);
                    end;
                    self.car.place.rotatePlace(self.speed*self.car.clock.tickResolution * (-1), self.car.place.center.x,self.car.place.center.y);
                --
                end;
            end;
end

association carConfig between
    Car [*] role car
    Config [1] role config
end

composition CarMotor between
    Car [1] role car
    Motor [1] role motor
end

------- ENVIRONMENT

class Environment
    attributes
        size : Size
    operations
        isWithin (tuple1 : Tuple(x:Real,y:Real,z:Real)) : Boolean = tuple1.x >= 0 and tuple1.x <= size.length
                                                                and tuple1.y >= 0 and tuple1.y <= size.width
                                                                and tuple1.z >= 0 and tuple1.z <= size.height
end

abstract class EnvironmentElement
    end

class ElementPart
    attributes
       place: Place
    end

class Line < EnvironmentElement
    attributes
        color: Color
    end

class Box < EnvironmentElement
    attributes
    end

association EnvironmentCar between
    Environment [1] role env
    Sensor [*] role sensor
    end

composition ElementOnTheFloor between  
    Environment [1] role env
    EnvironmentElement [*] role element
    end

composition ElementParts between
    EnvironmentElement [1] role element
    ElementPart [1..*] role part
    end

------- SIMULATION 

abstract class ActiveObject
    operations
        action() begin end
    end

class Clock
    attributes
        now : Integer                 init : 0
        tickResolution : Integer      init : 1
    operations
        tick()
            begin
                    declare snapshot : Snapshot;
                    for object in self.activeObject do
                        object.action();
                    end;
                    self.now := self.now + self.tickResolution;
                    snapshot := new Snapshot();
                    snapshot.carCenter := Car.allInstances()->asOrderedSet()->first().place.center;
                    snapshot.carAngle := Car.allInstances()->asOrderedSet()->first().place.angle;
                    snapshot.carLength := Car.allInstances()->asOrderedSet()->first().place.length;
                    snapshot.carWidth := Car.allInstances()->asOrderedSet()->first().place.width;
                    snapshot.carHeight := Car.allInstances()->asOrderedSet()->first().place.height;
                    snapshot.environment := Environment.allInstances()->asOrderedSet()->first;
                    --snapshot.environmentLength := Environment.allInstances()->asOrderedSet()->first().size.length;
                    --snapshot.environmentWidth := Environment.allInstances()->asOrderedSet()->first().size.width;
                    --snapshot.environmentHeight := Environment.allInstances()->asOrderedSet()->first().size.height;
                    snapshot.time := self.now;
            end
    end

association Timing between
    Clock [1] role clock
    ActiveObject [*] role activeObject ordered
end

-- Snapshots

class Snapshot
    attributes
        carCenter : Tuple(x:Real,y:Real,z:Real)
        carAngle : Real
        carLength : Real
        carWidth : Real
        carHeight : Real
        environment : Environment
        --environmentLength : Real
        --environmentWidth : Real
        --environmentHeight : Real
        time : Integer
    operations
        init(car : Car, environment : Environment, time : Integer)
            begin
                self.carCenter := car.place.center;
                self.carAngle := car.place.angle;
                self.carLength := car.place.length;
                self.carWidth := car.place.width;
                self.carHeight := car.place.height;
                self.environment := environment;
                --self.environmentLength := environment.size.length;
                --self.environmentWidth := environment.size.width;
                --self.environmentHeight := environment.size.height;
                self.time := time;
            end
end
