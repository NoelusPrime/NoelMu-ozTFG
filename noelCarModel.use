model Car

--- Basic Class Types

class Config
    attributes
        PI : Real derive = (1.0).atan()*4
        RAD_TO_DEG : Real derive = 180 / PI
        DEG_TO_RAD : Real derive = PI / 180
        LINEAR_PRECISSION : Real derive = 0.00000001
end

enum Action {Forward, Rotate}
enum Color {Black,Yellow, Red, Blue}

class Position
    attributes
        pos : Tuple(x : Real, y : Real, z : Real)
    operations
        move( dx: Real, dy: Real, dz: Real)
            begin
                self.pos:=Tuple{x:self.pos.x+dx, y:self.pos.y+dy,z:self.pos.z+dz};
            end
        rotatePoint (tuple1 :Tuple(x : Real, y : Real, z : Real), angle1: Real, posX: Real, posY: Real) : Tuple(x : Real, y : Real, z : Real) = 
            Tuple{
                x: (tuple1.x - posX) * ((config.DEG_TO_RAD*angle1).cos()) - (tuple1.y - posY) * ((angle1*config.DEG_TO_RAD).sin()) + posX,
                y: (tuple1.x - posX) * ((config.DEG_TO_RAD*angle1).sin()) + (tuple1.y - posY) * ((angle1*config.DEG_TO_RAD).cos()) + posY,
                z: (tuple1.z)}
        outOfEnvironment (env : Environment) : Boolean = pos.x < 0 or pos.x > env.size.length or
                                                        pos.y < 0 or pos.y > env.size.width or
                                                        pos.z < 0 or pos.z > env.size.height
end

association positionConfig between
    Position [*] role position
    Config [1] role config
end


class Pose < Position
    attributes
        angle : Real
    operations
        rotate(angle : Real)
        begin
            self.angle := angle;
        end
end

class Size
    attributes
        length : Real
        width : Real
        height : Real
end

class Place < Size,Pose
    attributes

        --a1 : Position derive =

        b1 : Tuple(x : Real, y : Real, z : Real) derive = self.pos
        b2 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()),z:self.pos.z}
        b3 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z}
        b4 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()) - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()) + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z}

        h1 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x,y:self.pos.y,z:self.pos.z + self.height}
        h2 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()),z:self.pos.z + self.height}
        h3 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z + self.height}
        h4 : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()) - (self.width * (angle * config.DEG_TO_RAD).sin()),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()) + (self.width * (angle * config.DEG_TO_RAD).cos()),z:self.pos.z + self.height}

        center : Tuple(x : Real, y : Real, z : Real) derive = Tuple{x:self.pos.x + (self.length * (angle * config.DEG_TO_RAD).cos()/2) - (self.width * (angle * config.DEG_TO_RAD).sin()/2),y:self.pos.y + (self.length * (angle * config.DEG_TO_RAD).sin()/2) + (self.width * (angle * config.DEG_TO_RAD).cos()/2),z:self.pos.z}
    operations

        minimumX (angle1 : Real) : Real = (((((rotatePoint(Tuple{x:b1.x,y:b1.y,z:b1.z},angle1,0,0)).x).min(rotatePoint(Tuple{x:b2.x,y:b2.y,z:b2.z},angle1,0,0).x)).min(rotatePoint(Tuple{x:b3.x,y:b3.y,z:b3.z},angle1,0,0).x)).min(rotatePoint(Tuple{x:b4.x,y:b4.y,z:b4.z},angle1,0,0).x))

        maximumX (angle1 : Real) : Real = (((((rotatePoint(Tuple{x:b1.x,y:b1.y,z:b1.z},angle1,0,0)).x).max(rotatePoint(Tuple{x:b2.x,y:b2.y,z:b2.z},angle1,0,0).x)).max(rotatePoint(Tuple{x:b3.x,y:b3.y,z:b3.z},angle1,0,0).x)).max(rotatePoint(Tuple{x:b4.x,y:b4.y,z:b4.z},angle1,0,0).x))

        minimumY (angle1 : Real) : Real = (((((rotatePoint(Tuple{x:b1.x,y:b1.y,z:b1.z},angle1,0,0)).y).min(rotatePoint(Tuple{x:b2.x,y:b2.y,z:b2.z},angle1,0,0).y)).min(rotatePoint(Tuple{x:b3.x,y:b3.y,z:b3.z},angle1,0,0).y)).min(rotatePoint(Tuple{x:b4.x,y:b4.y,z:b4.z},angle1,0,0).y))

        maximumY (angle1 : Real) : Real = (((((rotatePoint(Tuple{x:b1.x,y:b1.y,z:b1.z},angle1,0,0)).y).max(rotatePoint(Tuple{x:b2.x,y:b2.y,z:b2.z},angle1,0,0).y)).max(rotatePoint(Tuple{x:b3.x,y:b3.y,z:b3.z},angle1,0,0).y)).max(rotatePoint(Tuple{x:b4.x,y:b4.y,z:b4.z},angle1,0,0).y))

        collidingX (place1 : Place, angle : Real) : Boolean = (self.minimumX (angle) <= place1.maximumX (angle)) and (self.maximumX (angle) >= place1.minimumX (angle))

        collidingY (place1 : Place, angle : Real) : Boolean = (self.minimumY (angle) <= place1.maximumY (angle)) and (self.maximumY (angle) >= place1.minimumY (angle))     

        collidingAxis (place1: Place, angle1: Real) : Boolean = ((collidingX (place1,-self.angle  )) and (collidingY (place1,-self.angle))) 
                                                                and 
                                                                ((collidingX (place1,-place1.angle)) and (collidingY (place1,-place1.angle)))
                                                                
        -- Este método debería comprobar si rotados el place actual y el "place1" parámetro "angle1" ángulos con respecto al origen de coordenadas, existe algún eje (ya sea x o y)
        -- en el cual los 2 se superpongan

        isIntersectingWith (place1: Place) : Boolean = (collidingAxis (place1,self.angle)) and (collidingAxis (place1,place1.angle))
        -- Este método comprueba si el place actual está interseccionando en algún punto con el objeto place1 que se le pasa por parámetro
        
        --Cuidado con el sentido de los ángulos y con el sentido de girar los places con respecto al centro de coordenadas
        --outOfEnvironment () : Boolean = true

        rotatePlace(angle1: Real)
            begin
                self.pos := self.rotatePoint(self.pos,angle1,self.center.x,self.center.y);
                self.angle := self.angle + angle1;

                --Hay que rotar la esquina principal con respecto al centro del place
            end
end

--- Car

class Car < ActiveObject
    attributes
        place : Place
        action : Action
        isMoving : Boolean
        isRotating : Boolean
    operations
        init()
            begin
                declare place: Place, motor: Motor, behavior: TestBehavior, clock: Clock;

                place := new Place();
                clock := new Clock();

                self.place := place;
                place.length := 5;
                place.width := 10;
                place.height := 5;
                place.pos := Tuple{x=10,y=10,z=0};
                place.angle := 0;

                behavior := new TestBehavior();
                
                insert (self,behavior) into CarBehaviors;
                insert (clock,self) into Timing;

                motor := new Motor();
                insert(self, motor) into CarMotor;
            end
        action()
            begin
                for b in self.behavior do
                    b.executeBehavior();
                end;
            end
    end

abstract class Behavior
    operations
        executeBehavior() begin end
    end

class TestBehavior < Behavior
    operations
        executeBehavior()
            begin
                self.car.motor.forward();
            end
end

composition CarBehaviors between
    Car [1] role car
    Behavior [1..*] role behavior ordered
end 

abstract class Sensor
end

class TouchSensor < Sensor
    attributes
        position : Position
        isPressed : Boolean     derived: false
end

class LightSensor < Sensor
    attributes
        position : Position
        lightValue : Integer    derived:45
end

class UltrasonicSensor < Sensor
    attributes
        pose : Pose
        distance : Integer   derived: 40 -- cm
end

composition UltrasonicSensorConnection between
    Car [1] role car
    UltrasonicSensor [0..1] role sound
end

composition LightSensorConnection between
    Car [1] role car
    LightSensor [0..1] role light
end

composition TouchSensorConnection between
    Car [1] role car
    TouchSensor [0..2] role touch
end

class Motor 
    attributes
        speed : Real init: 10
    operations

        --canGoForward() : Boolean
        --begin
          --  declare cocheFantasma : Car, motorFantasma : Motor, placeFantasma : Place;
           -- cocheFantasma := self.car;
            --motorFantasma := self;
            --placeFantasma := self.car.place;
            --motorFantasma.forward();

            --Comrpobar si cocheFantasma intersecciona con algun objeto
            --Devolver true si no intersecciona con nada

        --end
        -- La idea es crear un cochecito fantasma en la misma posicion que el original, llamar al metodo forward del cochecito fantasma y al moverse, comprobar si está superpuesto con algun otro objeto.
        -- Si es así, la función debería devolver un falso (no puede ir hacia delante el coche original), y en caso contrario, devolver true. Hay que destruir el coche fantasma antes de terminar dicha operacion.

        forward()
            begin
                declare previousPos : Tuple(x:Real,y:Real,z:Real);
                previousPos := self.car.place.pos;
                self.car.place.move(
                                                    self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.config.DEG_TO_RAD).cos(),
                                                    self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.config.DEG_TO_RAD).sin(),
                                                    0    
                                    );
                if (ElementPart.allInstances->select(p | self.car.place.isIntersectingWith(p.place))->isEmpty() = false) then
                    self.car.place.pos := previousPos;
                end
            end

        backward()
            begin
                declare previousPos : Tuple(x:Real,y:Real,z:Real);
                previousPos := self.car.place.pos;
                self.car.place.move(
                                                    -self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.config.DEG_TO_RAD).cos(),
                                                    -self.speed*self.car.clock.tickResolution*(self.car.place.angle * self.config.DEG_TO_RAD).sin(),
                                                    0    
                                    );
                if (ElementPart.allInstances->select(p | self.car.place.isIntersectingWith(p.place))->isEmpty() = false) then
                    self.car.place.pos := previousPos;
                end
            end

        
        rotateClockwise()
            begin
                self.car.place.angle := self.car.place.angle - self.speed*self.car.clock.tickResolution;
            end
        rotateAntiClockwise()
            begin
                self.car.place.angle := self.car.place.angle + self.speed*self.car.clock.tickResolution;
            end
end

association motorConfig between
    Motor [*] role motor
    Config [1] role config
end

composition CarMotor between
    Car [1] role car
    Motor [1] role motor
end

------- ENVIRONMENT

class Environment
    attributes
        size : Size
end

abstract class EnvironmentElement
    end

class ElementPart
    attributes
       place: Place
    end

class Line < EnvironmentElement
    attributes
        color: Color
    end

class Box < EnvironmentElement
    attributes
    end

association EnvironmentCar between
    Environment [1] role env
    Sensor [*] role sensor
    end

composition ElementOnTheFloor between  
    Environment [1] role env
    EnvironmentElement [*] role element
    end

composition ElementParts between
    EnvironmentElement [1] role element
    ElementPart [1..*] role part
    end

------- SIMULATION 

abstract class ActiveObject
    operations
        action() begin end
    end

class Clock
    attributes
        now : Integer                 init : 0
        tickResolution : Integer      init : 1
    operations
        tick()
            begin
                    for object in self.activeObject do
                        object.action();
                    end;
                    self.now := self.now + self.tickResolution;
            end
    end

association Timing between
    Clock [1] role clock
    ActiveObject [*] role activeObject ordered
end
